
<html>
    <head>
        <link rel="stylesheet" href="style.css"/>
    </head>
  <body>
    <h1>Retool Monster</h1>

    <h2>exec into postgres</h2>
    <pre>
dc exec postgres bash -c "psql -U retool_internal_user -d hammerhead_production"</pre
    >

    <h2>scp database dumb to your machine</h2>
    <pre>
scp -i “YOUR_PEM_FILE.pem” YOUR_RETOOL_INSTANCE_URL:/home/ubuntu/retool-onpremise/retool_db_dump.sql ~/dev/retool_db_dump.sql
    </pre>

    <h2>completely nuke ec2 (or any machine's) docker</h2>
    <pre>
docker kill $(docker ps -q) && docker rm $(docker ps -a -q) && docker rmi $(docker images -q)</pre
    >

    <h2>minimal docker-compose deployment</h2>
    <p>docker-compose.yml</p>

    <pre>
version: '3'
      services:
        api:
          image: tryretool/backend:latest
          env_file: ./docker.env
          depends_on:
            - postgres
          command: bash -c "./docker_scripts/wait-for-it.sh postgres:5432; ./docker_scripts/start_api.sh"
          ports:
            - 4000:3000

        postgres:
          image: postgres:9.6.5
          env_file: ./docker.env
          volumes:
            - ./.db/retool:/var/lib/postgresql/data
      </pre
    >
    <p>docker.env</p>
    <pre>
        ## Set node environment to production
        NODE_ENV=production

        ## Set the JWT secret for the API server
        JWT_SECRET=YOUR_JWT_SECRET

        ## Set and generate postgres credentials
        POSTGRES_DB=retool
        POSTGRES_USER=retool
        POSTGRES_HOST=postgres
        POSTGRES_PORT=5432
        POSTGRES_PASSWORD=retool
        RT_POSTGRES_USER=retool
        RT_POSTGRES_HOST=postgres
        RT_POSTGRES_PORT=5432
        RT_POSTGRES_PASSWORD=retool

        ## Set variables for the nginx server
        # Change '' to retool.yourcompany.com to set up SSL properly
        DOMAINS= -> http://api:3000

        ## Set key to encrypt and decrypt database passwords, etc.
        ENCRYPTION_KEY=DkDeuq/YB7Rdh3MacpxxajRBLu7SW+EmDzANA7Z6W8PuKntBPugqxR+x1LlnsbEB

        ## Google SSO configuration
        # CLIENT_ID=YOUR GOOGLE CLIENT ID

        ## Okta configuration
        # Do not include an https:// in the URL below
        # OKTA_URL=dev-xyz.oktapreview.com
        # OKTA_CLIENT_ID=YOUR OKTA CLIENT ID

        ## License key
        LICENSE_KEY=your_key_here
        COOKIE_INSECURE=true
    </pre>

    <h2>simple promise loop</h2>
    <pre>
        const arr = [1,2,3,4,"last item"].map(row => {
            return targetQuery.trigger({
                additionalScope: {
                    key1: row
                }
            });
        });
        
        return Promise.all(arr)
</pre
    >
    <h2>batching js queries</h2>
    <pre>
        // Queries in one batch will run in parallel.
        // You can tweak batch size if you see server errors related to
        // parallel execution
        
        const arr = _.range(200) //evaluates as [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
        const batchSize = 50
        
        // Note, this is wrapped in a function so that we don't evaluate
        // promises immediately, but only when we run them in a batch
        const queries = arr.map((item) => () => {
          return targetQuery.trigger({
            additionalScope: {"key1":item} //passes the value being mapped over as keyName
          });
        })
        
        async function runAllQueries(queries) {
          const batches = _.chunk(queries, batchSize);
          const results = [];
          while (batches.length) {
            const batch = batches.shift();
            // This map here actually runs the promise
            const result = await Promise.all(batch.map(fn => fn()));
            results.push(...result)
          }
          return results
        }
        
        return runAllQueries(queries)</pre
    >
  </body>
</html>
